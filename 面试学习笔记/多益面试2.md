# 自我介绍

面试官好, 我叫邱奕浩, 今年将毕业于广东财经大学, 专业是计算机科学与技术, 做过两个项目, 一个是选课系统, 是课程设计的项目组队完成, 要求是解决抢课的高并发问题, 另一个是用爬虫做的一个信息聚合的手机应用, 是毕业设计项目, 自己设计数据库表和程序, 锻炼了项目的设计能力和开发能力和学习能力.  现在想应聘贵公司的互联网产品研发工程师这个岗位,

# tcp三次握手四次挥手

第一次握手: 客户端发 syn包, syn置1, seq=x, 发送到服务端, 此时客户端是syn_sent状态

第二次握手: 服务器收到syn包, 发ack=x+1, syn=1的包, seq为y的包给客户端, 此时服务端是syn_rcvd状态

第三次握手: 客户端收到服务器的syn包, 发ack=y+1的包, 此时客户端是established状态, 服务端收到后也变为established状态



第一次挥手: 主动关闭方发送FIN, 此时主动关闭方还能接收数据

第二次挥手: 被动方收到fin包后, 发ack=seq+1给对方, 

第三次挥手: 被动方发fin包, 用来关闭数据传输, 

第四次挥手: 主动方收到fin后, 发送ack=seq+1给对方, 结束



# http与https的区别

http: 明文数据传输的网络协议, 

https在http基础上增加了数据加密, 加入SSL层, 

1. https需要ca申请证书
2. http是明文, https是具有安全性的ssl加密传输协议
3. 前者端口80. 后者443
4. http是无状态连接, 后者是



# web安全问题

## XXS, 跨站脚本攻击



## SQL注入

通过构建特殊的输入作为参数传入web应用, 这些输入是sql的语法中的一些组合, ' or '1=1, 查询中的参数是字符串拼接生成sql语句的话就有sql漏洞

常见: 没有正确过滤转义字符, 

最佳处理: 预编译语句, 绑定变量, / 限制数据类型, 统一数据格式, 在前端和后端都校验 / 数据库用户分权

# 项目-项目redis, springboot原理, mybatis

## 描述工作经验和项目

我的项目是选课系统, 用到的技术springboot+mybatis, 数据库mysql, 项目是和舍友两个人开发的, 我和舍友一起设计数据库表, 然后分模块写, 我主要负责管理员模块和选课时间模块, 高并发测试, 网页是用的后台管理的比较通用的模板, 架构是最基本的controller, service, dao三层. 高并发处理是用redis缓存课程信息和选课结果, rabbitmq做消息队列, 

遇到问题: 数据库表设计应该先设计数据模型再设计表, git不会用

表: admin, course, grade, select, student, teacher , time



描述项目, 使用技术, 个人负责的模块, 结果, 







用爬虫做信息聚合app, 用到的技术springboot+mybatis, 数据库mysql,爬虫用webmagic框架,  客户端程序用flutter写, 项目是自己开发的, 从功能需求分析到数据模型设计到数据库表到前端界面, 前后端数据传输用json, 架构是mvvm . flutter和webmagic都是第一次用, 现学现卖, 

愿意尝试新技术: 

遇到问题会先百度, flutter第一次用有很多技术层面的问题, 网上视频资料->模仿项目使用-> 加好多flutter的群, 群内咨询大神, 

学习到了: 快速上手新技术, 数据库表设计, 功能需求分析, 模仿

## 针对项目深入问技术问题或技术实现

spring: ioc控制反转和aop面向切面

**优点** : 轻量级非侵入, 控制反转实现松耦合(依赖注入) , 面向切面aop业务与系统服务分开, 容器管理对象, 设计优良的mvc, 事务管理

七大模块: aop, orm, web, webmvc, dao, context, core

IOC与AOP的理解:

ioc是一种设计思想, 将创建对象的控制权交给框架来管理, 需要对象的时候从工厂中获取, 不用考虑如何创建对象, spring通过xml文件配置bean, 后来springboot用注解配置

aop将与业务无关的, 却为业务模块共同调用的功能如事务处理, 日志管理等封装, 减少重复代码, 降低模块间的耦合, 有利于扩展和维护, springaop基于动态代理

bean作用域: singleton, prototype, request, session, global-session

bean生命周期: 容器找到配置文件bean定义, 用反射创建bean实例, 用set方法设置值, 如果有init-method, 

用到的设计模式: 工厂模式, 代理模式, 单例模式, 模板方法模式, 包装类模式



springmvc

springmvc工作原理:

围绕DispatcherServlet: 请求发送到DispatcherServlet, 向HandlerMapping查找handler(xml或者注解), 找到后返回handler, 前端控制器调用处理器适配器执行handler, handler返回ModelAndView对象, 处理器适配器返回该对象给前端适配器, 前端适配器请求视图解析器进行视图解析, 视图解析器返回view, 前端控制器进行视图渲染, 然后响应用户请求







mybatis

半orm框架, 内部封装jdbc, 程序员可直接编写sql, 使用xml或者注解来配置, 

优点: 可以使用sql语句编程, 灵活, sql写在xml里解除与程序的耦合, 统一管理, 减少jdbc冗余代码, 与各种数据库兼容, 很好的与spring集成, 提供银蛇标签, 将对象与数据库字段关系映射

#{} 与\${}区别: \#是预编译处理, 有效防止sql注入 , ​\$是字符串替换

实体类与字段名不同: 1.别名, 2.用\<resultMap\>映射字段与属性名的对应关系

分页: 1.用mybatis的rowBounds对象分页, 2.物理分页limit 起始 长度







springboot

核心注解:SBA, 包含:SBC, EAC, CS



mysql

数据库引擎: MYISAM, innodb

区别: 事务外键行锁不支持, 全文索引支持, 速度快, 空间小

支持事务外键行锁, 不支持全文索引, 速度慢一点, 空间大, 安全高

事务特性: 原子一致性隔离性, 持久性

4种索引: 主键唯一普通全文

sql优化: 

查询语句不用select *; 少用子查询, 用关联查询, 少用in或not in(exists或关联查询); 避免在where子句中用!=或<>操作符(精确的主键条件避免放弃索引全表扫描); 避免在where子句对字段进行null判断(又会全表扫描)

避免select * , 避免子查询, 避免全表扫描

drop. delete, truncate区别

drop删除表结构, delete和truncate删数据不删表结构, delete事务提交才会生效, truncate和drop是立即生效







并发带来的问题

脏读, 丢失修改, 不可重复读, 幻读

事务隔离级别, 默认隔离级别: 

读取未提交, 读取已提交, 可重复读, 可串行化, 默认可重复读

大表优化: 

禁止不带任何限制数据范围条件的查询语句, 读写分离, 垂直分区, 一张表拆成多张, 水平分区200w



redis

rabbitmq

mvvm

webmagic

另外的爬虫框架

flutter

## 针对某技术问项目里一定会遇到的问题: 数据库-索引

一种数据结构, 加快数据检索的速度

hash索引和b+树索引, innodb默认b+树索引

b+树是多路平衡查询树, 节点天然有序, 范围查询时不用做全表扫描

hash适合等值查询无法范围查询, hash无法利用索引排序, 大量重复键值情况下hash效率低, 有hash碰撞问题



























# 求1000以内所有质数, 并各位数字之和是偶数

for(int i=2;i<n;i++){

​	if(n%i==0){

​	return false;	

}

}

# 全排列

# 优化sql

# varchar与char的区别

1.char定长, varchar是长度可变, 插入长度小于定长时, 用空格填充, char存取速度比varchar快, 方便存储和查找, 

2.容量不同,char最多255个字符, 与编码无关,var最多65532个字符, 大小看使用的字符集

# varchar的单位是什么

字符

# 继承有什么特性

子类拥有父类非私有方法属性, 

子类可以扩展父类

子类可以重写父类方法

只能单继承, 可以多重继承

提高了类之间的耦合性

# 如何保证redis与数据库的一致性

1.redis不立即更新, 等数据过期才从db里取, 顺带重新set redis, 缺: 有一段时间的数据不一致

2.更新db时代码更新后马上del掉redis的数据, 缺: 1s内的数据不一致

3.数据永远从redis中取, 当实际数据更新时写入redis



# redis常见面试题

# redis的数据结构有哪些

# 如何理解幂等性

幂等性是系统接口对外的一种承诺, 承诺只要调用接口成功, 多次调用对系统的影响是一致的, 强调api的安全性, 声明为幂等的接口会认为外部调用失败是常态, 并且失败后必然会有重试,

# 登录功能的具体流程

# redis与数据库的区别

redis内存性数据库, key-value数据库, 也可以持久化, 速度快并发能力强

mysql关系型数据库, 持久化

# 高并发处理

1.html静态化, 2.图片服务器分离, 3.数据库集群, 主写从读, 分库分表 4.缓存 5.负载均衡 6.cdn服务





# 堆栈哪个运行速度更快

栈的速度更快, 访问堆要先获得指针, 第二次才真正获取数据, 栈直接获取

# linux基本命令

复制: cp -r /dir .

链接: ln -s

修改权限: chmod 

# 进程线程进程通信

进程通信: 管道, 文件, 消息队列, 信号量(实现进程间的互斥而不是通信数据传输), 共享内存区

# jvm内存模型

1.7: pc程序计数器, 虚拟机栈, 本地方法栈, 堆, 方法区( 运行时常量池),    永久代实现方法区, hotspot

1.8: 取消永久代, 元空间取代, 元空间是本地内存, 元空间存类信息, 静态变量和常量池归入到堆中了

# gc机制

哪里: 堆和方法区会gc, 

哪些: 引用计数法, 可达性分析算法(根据GC root做起点向下搜索, 引用链), 

操作: 标记清除算法, 复制算法, 标记清除整理,  分代算法

内存担保机制: 大对象直接进入老年代

有哪些GC器: CMS: 短暂停顿 , 并发收集器, 垃圾线程与用户线程同时工作, 用标记清除算法: 步骤: 初始标记stw, 并发标记, 重新标记stw, 并发清除 缺点: cpu敏感, 无法处理浮动垃圾, 空间碎片

, G1, 针对大容量内存和多核, 低停顿并行并发, 分代收集, 整体标记整理, 局部复制

步骤: 初始标记, 并发标记, 最终标记, 筛选回收

# 多线程锁问题

# 数据库索引

# 数据库常见面试题

# java面试常见问题

# 排序算法-快排, 

# 简单算法







进入秒杀页面, 

请求->根据课程id从redis中获得库存, 减少库存默认能选, 直接减1, 判断库存是否小于0,成功选择的操作进入消息队列,同时更新选课表, MQreceiver从队列中取消息, 对课程表中的课程余量更新操作, 











# java hashmap的底层实现 避免冲突的方法 java解决冲突的方法是哪个

1.7是位桶+链表, 链地址法处理冲突

开放定址法, 再哈希, 链地址

1.8是桶+链表+红黑树, 超过阈值(8)将链表转红黑树



# 创建多线程的三种方式，java多线程锁

1.继承Thread类, 2. 实现Runnable接口, 3.实现Callable接口并通过FutureTask创建线程, 4. 使用

#  TCP、UDP协议的区别

tcp: 有连接, 可靠传输(流量控制和拥塞控制), 一对一, 速度慢一点, 面向字节流, 首部min20字节, max60字节, 文件传输,

udp: 无连接不可靠, 一对一一对多多对多, 面向报文, 首部8字节, , 速度快一点, 视频会议

# 快排原理

选一个数做基准数, 大于这个数的放它右边, 小于的放它左边, 再对左右区间重复第二步, 直到左右区间只有一个数

# mysql 事务特性，讲讲隔离性，索引的类型、作用，查询调优。

原子性, 一致性, 隔离性, 持久性, 索引: 主键索引, 唯一索引,,普通索引, 全文索引, 加快数据检索速度, 

# java怎么解决http无状态

url参数传递, cookie, session



















# 加班的看法





































