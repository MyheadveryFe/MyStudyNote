排序稳定性-不: 快排 , 稳: 插冒归并

```
不稳定的：快些（希）选堆

nlog2n：快些（希）归队（堆）。


1.选择排序：不稳定，时间复杂度 O(n^2)
选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。
2.插入排序：稳定，时间复杂度 O(n^2)
插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入。
3.冒泡排序：稳定，时间复杂度 O(n^2)
冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。
4.堆排序：不稳定，时间复杂度 O(nlog n)
堆排序是一种树形选择排序，在排序过程中，将A[n]看成是完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
5.归并排序：稳定，时间复杂度 O(nlog n)
设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为A[l..m]，A[m+1..h]，将它们归并为一个有序数列，并存储在A[l..h]。
6.快速排序：不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n^2)
快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。
```

拓扑排序

O(nlogn)稳定排序算法

选择排序过程

递归算法时间复杂度计算

可用于遍历网络图的算法

斐波那契查找

```
首先 A：平均性能是斐波纳切黄金分割查找更好
B：有序表长度不需要一定要是一个斐波纳切数才行，是可以补齐成为一个斐波纳切数的  补最大的数目直到长度是斐波纳切数
C：最坏情况下斐波纳切查找性能比折半是要差的  
折半查找:log2n
```





不论线性表采用顺序存储结构还是链式存储结构，删除值为X的结点的时间复杂度均为O(n)。（ 对 ）



在有序表中，关于斐波那契查找和折半查找说法错误的是（）

正确答案: A B C  你的答案: B D (错误)

```
就平均性能而言，斐波那契查找的平均性能比折半查找差
只有有序表中元素个数n等于某个斐波那契数时才能用斐波那契查找算法
在最坏情况下，斐波那契查找的性能比折半查找好
折半查找时间复杂度为O(log2n)
```



分块查找-数据的组织方式



哪个排序算法最好最坏都是n^2



以下哪种排序算法对[1, 3, 2, 4, 5, 6, 7, 8, 9]进行排序最快

正确答案: A  你的答案: C (错误)

```
改良的冒泡排序
快速排序
归并排序
堆排序
```

改良的冒泡排序，当一轮循环中没有交换就结束排序。只要2轮循环。



下列哪种算法平均情况、最好情况和最坏情况下的时间复杂度都为o(n^2)（   ）

正确答案: A  你的答案: C (错误)

```
直接选择排序
直接插入排序
冒泡排序
归并排序
```





外部排序算法有:

平衡二叉的查找时间复杂度

KMP算法

给定的一个长度为N的字符串str,查找长度为P(P<N)的字符串在str中的出现次数.下面的说法正确的是()

正确答案: D  你的答案: 空 (错误)

```
不存在比最坏时间复杂度O(NP)好的算法
不存在比最坏时间复杂度O(N^2)好的算法
不存在比最坏时间复杂度O(P^2)好的算法
存在最坏时间复杂度为O(N+P)的算法
存在最坏时间复杂度为O(log(N+P))的算法
以上都不对
```



下列叙述中正确的是（ ）

正确答案: A  你的答案: C (错误)

```
对数据进行压缩存储会降低算法的空间复杂度
算法的优化主要通过程序的编制技巧来实现
算法的复杂度与问题的规模无关
数值型算法只需考虑计算结果的可靠性
```





图

https://blog.csdn.net/vamesary/article/details/69597467

无向图: 令n=|V|,e=|E|，则每个顶点度数之和等于2e；0<=e<=n(n-1)/2。

有向图: 设G=（V,E)是一个有向图，令n=|V|,e=|E|，则图G的每个节点的出度之和和入度之和相等等于e，0<=e<n(n-1)/2



设G是有p个顶点q条边的（简单）无向图，且G中每个顶点的度数不是k就是k+1，则G中度为k的顶点的个数是多少？

正确答案: B  你的答案: 空 (错误)

```
p/2；
p(k＋1)－2q；
pk；
p(p+1)。
```



若事务 T 对数据对象 A 加上 S 锁，则（ ）。

正确答案: C  你的答案: 空 (错误)

```
事务T可以读A和修改A，其它事务只能再对A加S锁，而不能加X 锁。
事务T可以读A但不能修改A，其它事务能对A加S锁和X锁。
事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X 锁。
事务T可以读A和修改A，其它事务能对A加S锁和X锁。
```

解答: 共享锁(S锁)又称为读锁，若事务T对[数据对象](https://baike.baidu.com/item/数据对象)A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

共享锁【S锁】
读锁, A加对T加S锁, A可以读, 其他的也可以加S但不能加X, 直到A释放S, 其他才可以加别的锁

排他锁【X锁】
写锁。A对T加X锁, A可读可写, 其他都不能读不能写

ReentrantLock就是一种排它锁。CountDownLatch是一种共享锁。





实体-联系模型: ER模型 , 就是抽象的实体与属性和联系的模型, eg : 老师-(名字, 工号, 年龄, 学科)

关系模型: 就是二维表= 数据库表, 元数据=实体, 列=属性

将实体-联系模型转换为关系模型时，实体之间多对多联系在关系模型中的实现方式是（  ）

正确答案: A  你的答案: D (错误)

```
建立新的关系
建立新的属性
增加新的关键字
建立新的实体
```



为了允许不同用户的文件使用相同的文件名，通常采用（    ）的方法。

正确答案: B  你的答案: A (错误)

```
重名翻译
多级目录
文件名到文件物理地址的映射
索引表
```





给定n个带权结点，其Huffman树的结构是唯一的(错误)

哈夫曼树构建: 一组数, 从数里选出两个最小的数, 组成树, 树根为两数和, 然后将这个树根加入到原来的数组里, 才循环挑最小的两个数...

最小带权路径WPL : 同层节点权值之和*路径长 + 下一层..

编码: 左为0右为1

树形不唯一, WPL是唯一的







邻接表: 无向图表示点到点的关系, 有向图表示点向点的关系

邻接多重表: 无向图存储, 所有依附于同一个顶点的边串联在同一链表中, 解决邻接表存储无向图时同一条边要存储两次的问题。

十字链表: 有向图

邻接多重表是无向图和有向图的链式存储结构。（ ）

正确答案: B  你的答案: A (错误)

```
正确
错误
```

无向图：多重链接表

有向图：十字链表&边集数组

共有：邻接表＆邻接矩阵



关于单向链表，以下说法正确的有（）

正确答案: A B C D  你的答案: A C D (错误)

```
单向链表中指向头结点的指针First，可用于单向链表的判空依据
单向链表中指向头结点的指针First，可用于定位所有其他结点的位置
单向链表插入，删除的时间复杂度小于查找的时间复杂度
单向链表允许在非表头进行插入或删除操作
```





ARP协议



根堆性质

下标从1开始,在含有n个关键字的小根堆(堆顶元素最小)中,关键字最大的记录有可能存储在()位置上

正确答案: D  你的答案: B (错误)

```
[n/2]
[n/2]-1
1
[n/2]+2
```

小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于[n/2]





hash表处理冲突的方式

1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）(二次探测再散列: d取+1^2, -1^2, +2^2, -2^2, +3^2, -3^2 ,...)
2.再哈希法
3.链地址法(Java hashmap就是这么做的)

设哈希表长为14，哈希函数是H(key)=key%11,表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的结点加到表中，用二次探测再散列法解决冲突，则放入的位置是(  )

正确答案: D  你的答案: A (错误)

```
8
3
5
9
```





若一棵具有n(n>0)个结点的二叉树的先序序列与后序序列正好相反，则该二叉树一定？

正确答案: C  你的答案: A (错误)

```
结点均无左孩子的二叉树
结点均无右孩子的二叉树
高度为n的二叉树
存在度为2的结点的二叉树
```



若系统在允许过程中，由于某种原因，造成系统停止运行，致使事务在执行过程中以非控制方式终止，这时内存中的信息丢失，而存储在外存上的数据未受影响，这种情况称为 （  ）。

正确答案: B  你的答案: C (错误)

```
事务故障
系统故障
介质故障
运行故障
```









树转二叉

树取其中一个子节点加入左子树, 该子节点的兄弟节点加入二叉树中子节点的右子树







cat查看指定行数

head -n k//打印前k行

head -n -k//打印除最后k行的其他内容

head往前打印, tail往后打印

tail -n k //打印最后k行

tail -n +k //从k行开始打印

sed -n '300-500p' 打印300-500行，正确







深度优先 广度优先





A:文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议。它属于网络传输协议的应用层。

B:SPX:顺序包交换 (Sequenced Packet Exchange)协议。是IPX协议簇中的第四层的面向连接的协议，相当于TCP/IP协议簇中的TCP协议;

C:Telnet协议是TCP/IP协议族的其中之一，是Internet远程登录服务的标准协议和主要方式，常用于网页服务器的远程控制，可供用户在本地主机运行远程主机上的工作。属于应用层;

D:点对点协议（英语：Point-to-Point Protocol，PPP）工作在数据链路层

E:TCP（Transmission Control Protocol 传输控制协议）是一种面向连接（连接导向）的、可靠的、基于IP的传输层协议,传输层

F：网际网络组管理协议（Internet Group Management Protocol或简写IGMP)是用于管理网际网络协议多播组成员的一种通信协议。网络层





二叉树的前序遍历是：-+abc*de/f，后序遍历是：bad*c+f/e-，则层序遍历和中序遍历依次为（）

正确答案: A B  你的答案: B (错误)

```
-+eac/b*fd、ab+d*c-ef/
-+eac/b*fd、ba+d*c-ef/
-+eacf/b*d、ab+d*c-fe/
-+eacf/b*d、ba+d*c-fe/
```

A,B应该都正确，只给出前序（根左右）和后续（左右根），如某点只有一个叶子节点时该叶子节点是可以任为左/右孩子的。





webservice

Webservice是跨平台，跨语言的远程调用技术;

它的通信机制实质就是xml数据交换;
它采用了soap协议（简单对象协议）进行通信





super和this执行顺序





在异常处理中，以下描述不正确的有

正确答案: D  你的答案: B (错误)

```
try块不可以省略
可以使用多重catch块
finally块可以省略
catch块和finally块可以同时省略
```





在jdk1.8之前，下列哪一种叙述是正确的（ ）

正确答案: D  你的答案: B (错误)

```
abstract修饰符可修饰字段、方法和类
抽象方法的body部分必须用一对大括号{ }包住
声明抽象方法，大括号可有可无
声明抽象方法不可写出大括号
```





try 中的 return 语句调用的函数先于 finally 中调用的函数执行，也就是说 try 中的 return 语句先执行，finally 语句后执行，但try中的 return 并不是让函数马上返回结果，而是 return 语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行 finally 语句后才真正开始返回。但此时会出现两种情况：
① 如果finally中也有return，则会直接返回finally中的return结果，并终止程序，函数栈中的return不会被完成
② 如果finally中没有return，则在执行完finally中的代码之后，会将函数栈中保存的try return的内容返回并终止程序





```
public static String toString(char c) { return String.valueOf(c); }
public static String valueOf(char c) { char data[] = {c};  return new String(data, true); }
```

返回的都是字符串,只有char变成 int 的时候才会变为对应的assic码





下面关于Spring的说法中错误的是（）

 正确答案: D  你的答案: A (错误)

```
Spring是一系列轻量级Java EE框架的集合
Spring中包含一个“依赖注入”模式的实现
使用Spring可以实现声明式事务
Spring提供了AOP方式的日志系统
```

Spring并没有为我们提供日志系统，我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。 





枚举类实例化

枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：

```
private` `AccountType(){ System.out.println(“It is a account type”); }
```

会变成：

```
private` `AccountType(String s, ``int` `i){``  ``super``(s,i); System.out.println(“It is a account type”); }
```

而在这个类中，会添加若干字段来代表具体的枚举类型：

```
public` `static` `final` `AccountType SAVING;``public` `static` `final` `AccountType FIXED;``public` `static` `final` `AccountType CURRENT;
```

而且还会添加一段static代码段：

```
static``{``  ``SAVING = ``new` `AccountType(``"SAVING"``, ``0``);``  ``... CURRENT = ``new` `AccountType(``"CURRENT"``, ``0``);``  ``$VALUES = ``new` `AccountType[]{``     ``SAVING, FIXED, CURRENT``  ``} }
```

以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）

在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。





java关键字

这个关键字常见的坑：

true、false、null都不是关键字

goto、const、是保留的关键字



下列说法正确的是（）

正确答案: A B  你的答案: A C D (错误)

```
JAVA程序的main方法必须写在类里面
JAVA程序中可以有多个名字为main方法
JAVA程序中类名必须与文件名一样
JAVA程序的main方法中，如果只有一条语句，可以不用{}（大括号）括起来
```

A，java是强类型语言，所有的方法必须放在类里面，包括main

B ,java中可以有多个重载的main方法，只有public static void main(String[] args){}是函数入口

C，内部类的类名一般与文件名不同

D，函数都必须用{}括起来，不管是一条语句还是多条语句





Java语言中，下面哪个语句是创建数组的正确语句？(   )

正确答案: A B D E  你的答案: A D (错误)

```
float f[][] = new float[6][6];
float []f[] = new float[6][6];
float f[][] = new float[][6];
float [][]f = new float[6][6];
float [][]f = new float[6][];
```

二维数组定义，一维长度必须定义，二维可以后续定义





以下哪些jvm的垃圾回收方式采用的是复制算法回收

正确答案: A D  你的答案: A (错误)

```
新生代串行收集器
老年代串行收集器
并行收集器
新生代并行回收收集器
老年代并行回收收集器
cms收集器
```

```
两个最基本的java回收算法：复制算法和标记清理算法
复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法
标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出
标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象
两个概念：新生代和年老代
新生代：初始对象，生命周期短的
永久代：长时间存在的对象
整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。
P.S：**Serial New收集器是针对新生代的收集器，采用的是复制算法**
**Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理**
**Parallel** **Scavenge（并行）收集器，针对新生代，采用复制收集算法**
**Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理
**
**Parallel** **Old（并行）收集器，针对老年代，标记整理**
**CMS收集器，基于标记清理
**
**G1收集器：整体上是基于标记** **整理** **，局部采用复制
**
**综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理**
```



排序算法时间复杂度

最好最坏一样的: 选, 堆 , 计, 基, 归,

不稳定的: 快,希, 选, 堆, 

最坏最慢: 插希选冒快桶

最好最快: 插希冒桶

平均nlog2n: 快 希 归 堆

























